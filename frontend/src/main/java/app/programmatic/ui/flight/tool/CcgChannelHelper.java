package app.programmatic.ui.flight.tool;

import com.foros.rs.client.model.advertising.channel.BehavioralChannel;
import com.foros.rs.client.model.advertising.channel.ExpressionChannel;
import com.foros.rs.client.model.entity.Status;
import app.programmatic.ui.account.dao.model.AdvertisingAccount;
import app.programmatic.ui.channel.service.ChannelService;
import app.programmatic.ui.common.tool.foros.ForosHelper;
import app.programmatic.ui.flight.dao.model.LineItem;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;


public class CcgChannelHelper {
    private ChannelService channelService;
    private ExpressionChannel ccgChannel;


    public CcgChannelHelper(ChannelService channelService, LineItem lineItem, AdvertisingAccountFetcher accountFetcher) {
        this.channelService = channelService;
        this.ccgChannel = lineItem.getCcgChannelId() == null ? newExpressionChannel(lineItem, accountFetcher.fetch()) :
                channelService.findExpressionUnchecked(lineItem.getCcgChannelId());
        if (ccgChannel == null) {
            throw new RuntimeException("Can't find expression channel id " + lineItem.getCcgChannelId());
        }
    }

    public Long saveChannelList(List<Long> channelIds, Long specialChannelId, Long whiteListId, Long blackListId) {
        List<Long> effectiveChannelIds = channelIds;
        if (specialChannelId != null) {
            effectiveChannelIds = new ArrayList<>(channelIds.size() + 1);
            effectiveChannelIds.addAll(channelIds);
            effectiveChannelIds.add(specialChannelId);
        }
        if (effectiveChannelIds.isEmpty()) {
            // Without ordinary behavioral channels expression channel will not work properly anyway
            return null;
        }

        BlackWhiteValidity validity = calcBlackWhiteListsValidity(whiteListId, blackListId);
        String expression = buildExpression(effectiveChannelIds,
                validity.isWhiteListValid() ? whiteListId : null,
                validity.isBlackListValid() ? blackListId : null);
        ccgChannel.setExpression(expression);
        return channelService.createOrUpdateAsAdmin(ccgChannel);
    }

    public Long getId() {
        return ccgChannel.getId();
    }

    public void deleteExisting() {
        if (ccgChannel.getId() == null || ccgChannel.getStatus() == Status.DELETED) {
            return;
        }

        ExpressionChannel toSend = new ExpressionChannel();
        toSend.setId(ccgChannel.getId());
        toSend.setStatus(Status.DELETED);
        channelService.createOrUpdateAsAdmin(toSend);

        ccgChannel.setStatus(Status.DELETED);
    }

    private static String buildExpression(List<Long> channelIds, Long whiteListId, Long blackListId) {
        String channelIdsStr = channelIds.stream()
                .map( id -> id.toString() )
                .collect(Collectors.joining("|", "(", ")"));

        return channelIdsStr +
                (whiteListId != null ? "&" + whiteListId.toString() : "") +
                (blackListId != null ? "^" + blackListId.toString() : "");
    }

    private static ExpressionChannel newExpressionChannel(LineItem lineItem, AdvertisingAccount account) {
        ExpressionChannel result = new ExpressionChannel();
        result.setExpression("");
        result.setAccount(ForosHelper.createEntityLink(fetchStandaloneId(account)));
        result.setName(buildName(lineItem));
        result.setVisibility("PRI");
        result.setCountry(account.getCountryCode());
        result.setDescription("Channel for line item " + lineItem.getName());

        return result;
    }

    private static Long fetchStandaloneId(AdvertisingAccount account) {
        return account.getAgencyId() != null ? account.getAgencyId() : account.getId();
    }

    private static String buildName(LineItem lineItem) {
        String lineItemIdentifier = lineItem.getId() != null ? ("LI " + lineItem.getId().toString()) :
                ("default LI (flight " + lineItem.getFlightId() + ")");
        return String.format("Expression channel for %s (auto-generated by UI at %s)",
                             lineItemIdentifier,
                             LocalDateTime.now().toString());
    }

    public interface AdvertisingAccountFetcher {
        AdvertisingAccount fetch();
    }

    private BlackWhiteValidity calcBlackWhiteListsValidity(Long whiteId, Long blackId) {
        List<Long> ids = Arrays.asList( whiteId, blackId ).stream()
                .filter( id -> id != null)
                .collect(Collectors.toList());
        if (ids.isEmpty()) {
            return new BlackWhiteValidity(false, false);
        }

        boolean isWhiteValid = false;
        boolean isBlackValid = false;
        List<BehavioralChannel> channels = channelService.findAllBehavioral(ids);
        for (BehavioralChannel channel : channels) {
            if (channel.getId().equals(whiteId) && !channel.getUrls().getPositive().isEmpty()) {
                isWhiteValid = true;
            }
            else if (channel.getId().equals(blackId) && !channel.getUrls().getPositive().isEmpty()) {
                isBlackValid = true;
            }
        }

        return new BlackWhiteValidity(isWhiteValid, isBlackValid);
    }

    private class BlackWhiteValidity {
        private boolean isWhiteListValid;
        private boolean isBlackListValid;

        public BlackWhiteValidity(boolean isWhiteListValid, boolean isBlackListValid) {
            this.isWhiteListValid = isWhiteListValid;
            this.isBlackListValid = isBlackListValid;
        }

        public boolean isWhiteListValid() {
            return isWhiteListValid;
        }

        public boolean isBlackListValid() {
            return isBlackListValid;
        }
    }
}
